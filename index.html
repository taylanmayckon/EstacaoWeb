<!DOCTYPE html>
<html lang='pt-br'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>DogAtmos - EmbarcaTech</title>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #1e3a5f;
            margin-bottom: 30px;
        }
        h2 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .main-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .sensor-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .chart-container {
            flex: 2;
            min-width: 300px;
            max-width: 700px;
        }
        .chart-container canvas {
            width: 100% !important;
            height: 300px !important;
        }
        .sensor-info {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .info-item, .input-group, .alert-status-container {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        .info-item p { margin: 0; font-size: 1.2em; font-weight: 500; }
        .info-item span { font-weight: 400; color: #007bff; }
        .input-group label, .alert-status-container label { display: block; margin-bottom: 5px; font-weight: 500; }
        .input-group input { width: 100%; padding: 8px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; }
        .alert-indicator { padding: 10px; border-radius: 8px; text-align: center; font-weight: bold; color: white; background-color: #4CAF50; transition: background-color 0.3s ease, opacity 0.3s ease; }
        .alert-indicator.triggered { background-color: #f44336; animation: blink 1.2s infinite ease-in-out; }
        @keyframes blink { 50% { opacity: 0.7; } }
    </style>

    <script src='https://cdn.jsdelivr.net/npm/chart.js'></script>

</head>
<body>

    <h1>DogAtmos - EmbarcaTech</h1>
    <div id='main-content' class='main-content'>
    </div>
    
    <div style='text-align: center; max-width: 1200px; margin: 40px auto 20px;'>
        <hr style='border: 0; height: 1px; background-color: #ddd;'>
        <h3>Desenvolvido por: Taylan Mayckon</h3>
        <p>Atividade da Fase 2 do EmbarcaTech, envolvendo uso dos sensores BMP280 e AHT20 para criar uma estação meteorológica com interface WEB.</p>
    </div>

    <script>
        const sensorConfig = [
            {
                id: 'AHT20_temperature', sensorName: 'AHT20', label: 'Temperatura', unit: '°C',
                color: [255, 99, 132], defaultMin: 0, defaultMax: 40, defaultOffset: 0
            },
            {
                id: 'AHT20_humidity', sensorName: 'AHT20', label: 'Umidade', unit: '%',
                color: [54, 162, 235], defaultMin: 30, defaultMax: 80, defaultOffset: 0
            },
            {
                id: 'BMP280_pressure', sensorName: 'BMP280', label: 'Pressão', unit: 'kPa',
                color: [75, 192, 192], defaultMin: 90, defaultMax: 110, defaultOffset: 0
            },
            {
                id: 'BMP280_temperature', sensorName: 'BMP280', label: 'Temperatura', unit: '°C',
                color: [255, 159, 64], defaultMin: 0, defaultMax: 40, defaultOffset: 0
            }
        ];

        const charts = {};
        const fetchInterval = 2000;

        function initializeDashboard() {
            const container = document.getElementById('main-content');
            sensorConfig.forEach(sensor => {
                const sensorHtml = `
                    <div class='sensor-row'>
                        <div class='chart-container'>
                            <h2>${sensor.sensorName} - ${sensor.label}</h2>
                            <canvas id='${sensor.id}_chart'></canvas>
                        </div>
                        <div class='sensor-info'>
                            <div class='info-item'><p>Valor Atual: <span id='current_${sensor.id}'>--</span> ${sensor.unit}</p></div>
                            <div class='input-group'><label for='min_${sensor.id}'>Limite Mínimo:</label><input type='number' id='min_${sensor.id}' value='${sensor.defaultMin}'></div>
                            <div class='input-group'><label for='max_${sensor.id}'>Limite Máximo:</label><input type='number' id='max_${sensor.id}' value='${sensor.defaultMax}'></div>
                            <div class='input-group'><label for='offset_${sensor.id}'>Offset de Calibração:</label><input type='number' id='offset_${sensor.id}' value='${sensor.defaultOffset}'></div>
                            <div class='alert-status-container'><label>Status do Alerta:</label><div id='alert_${sensor.id}' class='alert-indicator'>NORMAL</div></div>
                        </div>
                    </div>`;
                container.insertAdjacentHTML('beforeend', sensorHtml);

                // Adiciona o event listener para cada campo de input
                ['min', 'max', 'offset'].forEach(type => {
                    const inputElement = document.getElementById(`${type}_${sensor.id}`);
                    // Ao invés de passar o evento, apenas passamos o ID, pois a função já busca todos os valores
                    inputElement.addEventListener('change', () => handleConfigChange(sensor.id));
                });

                const [r, g, b] = sensor.color;
                charts[sensor.id] = new Chart(document.getElementById(`${sensor.id}_chart`).getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: sensor.label,
                            data: [],
                            borderColor: `rgba(${r}, ${g}, ${b}, 1)`,
                            backgroundColor: `rgba(${r}, ${g}, ${b}, 0.2)`,
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { title: { display: true, text: 'Tempo' } },
                            y: { title: { display: true, text: `${sensor.label} [${sensor.unit}]` }, beginAtZero: false }
                        },
                        animation: { duration: 500 }
                    }
                });
            });
        }

        function handleConfigChange(sensorId) {
            const sensor = sensorConfig.find(s => s.id === sensorId);
            const minInput = document.getElementById(`min_${sensorId}`);
            const maxInput = document.getElementById(`max_${sensorId}`);
            const offsetInput = document.getElementById(`offset_${sensorId}`);

            if (minInput.value === '') minInput.value = sensor.defaultMin;
            if (maxInput.value === '') maxInput.value = sensor.defaultMax;
            if (offsetInput.value === '') offsetInput.value = sensor.defaultOffset;
            
            const payload = {
                min: parseFloat(minInput.value),
                max: parseFloat(maxInput.value),
                offset: parseFloat(offsetInput.value)
            };
            
            fetch(`/config/${sensorId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
            .then(response => {
                if (!response.ok) {
                    console.error(`Falha ao atualizar a configuração para ${sensorId}`);
                } else {
                    console.log(`Configuração para ${sensorId} atualizada com sucesso!`);
                }
            })
            .catch(error => console.error('Erro na requisição:', error));
        }

        function loadConfig() {
            fetch('/config').then(res => res.json()).then(configData => {
                sensorConfig.forEach(sensor => {
                    const savedConfig = configData[sensor.id] || {};
                    document.getElementById(`min_${sensor.id}`).value = savedConfig.min ?? sensor.defaultMin;
                    document.getElementById(`max_${sensor.id}`).value = savedConfig.max ?? sensor.defaultMax;
                    document.getElementById(`offset_${sensor.id}`).value = savedConfig.offset ?? sensor.defaultOffset;
                });
            });
        }

        function updateData(){
            fetch('/data').then(res => res.json()).then(data => {
                const timestamp = new Date();
                sensorConfig.forEach(sensor => {
                    const dataArray = data[sensor.id];
                    if (!dataArray) return; 
                    
                    const alertStatus = data[`alert_${sensor.id}`];
                    updateCharts(charts[sensor.id], timestamp, dataArray);
                    document.getElementById(`current_${sensor.id}`).textContent = parseFloat(dataArray.at(-1)).toFixed(2);
                    checkAlerts(sensor.id, alertStatus);
                });
            });
        }

        function checkAlerts(sensorId, currentStatus){
            const alertIndicator = document.getElementById(`alert_${sensorId}`);
            let isAlertTriggered = (currentStatus === 'on');
            alertIndicator.classList.toggle('triggered', isAlertTriggered);
            alertIndicator.textContent = isAlertTriggered ? 'ALERTA!' : 'NORMAL';
        }

        function updateCharts(chart, lastTimestamp, newDataArray) {
            const newLabels = [];
            const dataLength = newDataArray.length;
            for (let i = 0; i < dataLength; i++) {
                const pointTimestamp = new Date(lastTimestamp.getTime() - (dataLength - 1 - i) * fetchInterval);
                newLabels.push(pointTimestamp.toLocaleTimeString('pt-BR'));
            }
            chart.data.labels = newLabels;
            chart.data.datasets[0].data = newDataArray;
            chart.update('none');
        }

        initializeDashboard();
        loadConfig(); 
        updateData(); 
        setInterval(updateData, fetchInterval);
    </script>
</body>
</html>